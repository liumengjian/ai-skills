# 三、项目页面结构

### 0. 项目目录结构示意图

> **说明**：以下为项目的**经典/标准目录结构示意图**，展示了微应用的标准文件组织方式。实际项目中的文件结构可能会根据具体需求略有调整，但整体结构保持一致。

```
项目根目录/
├── public/
│   └── index.html              # 项目 HTML 模板
├── src/
│   ├── main.js                 # 应用入口文件
│   ├── pages/                  # 应用页面文件夹
│   │   └── Container/          # 应用页面入口容器
│   │       ├── Entry/          # 应用首页
│   │       ├── UserList/       # 示例：用户列表页
│   │       │   ├── index.jsx
│   │       │   └── index.less
│   │       └── UserDetail_id/  # 示例：用户详情页（动态路由）
│   │           ├── index.jsx
│   │           └── index.less
│   ├── components/             # 公共组件目录
│   │   └── CommonButton/
│   │       ├── index.jsx
│   │       └── index.less
│   ├── api/                    # 应用接口服务管理
│   │   ├── user/               # 用户相关接口（小驼峰命名）
│   │   │   └── index.js
│   │   └── order/              # 订单相关接口
│   │       └── index.js
│   ├── enumerate/              # 应用枚举、常量、命名空间
│   │   ├── namespace/          # 命名空间定义
│   │   │   └── index.js
│   │   ├── enum/               # 枚举值
│   │   │   └── index.js
│   │   ├── constant/           # 常量
│   │   │   └── index.js
│   │   └── context/            # React 全局 Context（导出 InjectContext）
│   │       └── index.js
│   ├── hooks/                  # 自定义 Hooks 目录
│   │   └── useDict.js          # 示例：字典数据 Hook
│   └── utils/                  # 工具函数库
│       └── index.js
├── jjb.config.js               # 应用配置文件
├── jjb.babel.js                # Babel 配置文件
└── package.json
```

### 核心文件说明

- **应用入口文件**：`src/main.js`
  - 应用的启动入口文件，负责初始化 React 应用、注册路由、注册模型等

- **应用页面文件夹**：`src/pages`
  - 存放所有页面组件的根目录

- **应用接口服务管理**：`src/api`
  - 存放所有接口定义文件，使用 `declareRequest` 定义接口请求
  - 目录命名规范：统一使用 **小驼峰（camelCase）** 命名

- **应用枚举、常量、命名空间**：`src/enumerate`
  - `namespace/`：命名空间定义，使用 `defineNamespace` 定义
  - `enum/`：枚举值定义
  - `constant/`：常量定义
  - `context/`：React 全局 Context 定义，导出 `InjectContext` 上下文

- **自定义 Hooks 目录**：`src/hooks/`
  - 用于存放自定义 Hooks，如字典数据 Hook、业务逻辑 Hook 等
  - 字典数据获取统一使用 Hooks 方式（详细规范参考 [`chapters/11-接口与数据层规范.md`](../chapters/11-接口与数据层规范.md)"字典数据获取规范"部分）

- **应用页面入口容器**：`src/pages/Container`
  - **核心职责**：
    1. 作为应用页面入口容器，存放所有路由页面
    2. 负责应用全局主题配置
    3. 负责 `InjectContext` 上下文注册（值为 `antd useApp()` 值）
    4. 可以通过 `InjectContext` 访问 `antd/App` 里面的数据
  - **`InjectContext` 来源**：`InjectContext` 从 `src/enumerate/context` 导出，在 `src/pages/Container` 中进行注册和使用

- **项目 HTML 模板**：`public/index.html`
  - 项目的 HTML 模板文件，支持 EJS 模板语法，可通过 `windowInject` 配置注入外部资源

- **`InjectContext` 使用规范**：
  - **强制约束**：禁止直接使用 `antd` 的静态方法（`Modal.confirm`、`message.success()`、`notification.info()` 等），必须通过 `InjectContext` 获取 `context.modal`、`context.message`、`context.notification` 使用
  - **允许使用**：允许使用 `<Modal>` 组件标签形式（非静态方法）
  - **使用方式**：在组件中使用 `useContext(InjectContext)` 获取上下文对象
  - **使用示例**：
    ```javascript
    import React, { useContext } from 'react';
    import { Modal } from 'antd';
    import { InjectContext } from '~/enumerate/context';

    function MyComponent() {
      const context = useContext(InjectContext);
      const [modalOpen, setModalOpen] = useState(false);

      const handleSuccess = () => {
        // ✅ 正确：使用 context.message 替代 message.success() 静态方法
        context.message.success('操作成功！');
        // ❌ 错误：禁止使用 message.success() 静态方法
        // message.success('操作成功！');
      };

      const handleDelete = () => {
        // ✅ 正确：使用 context.modal.confirm 替代 Modal.confirm 静态方法
        context.modal.confirm({
          title: '确认删除',
          content: '确定要删除这条记录吗？',
          onOk: () => {
            // 删除逻辑
          },
        });
        // ❌ 错误：禁止使用 Modal.confirm 静态方法
        // Modal.confirm({ ... });
      };

      const handleNotify = () => {
        // ✅ 正确：使用 context.notification 替代 notification.info() 静态方法
        context.notification.info({
          message: '提示',
          description: '这是一条通知消息',
        });
        // ❌ 错误：禁止使用 notification.info() 静态方法
        // notification.info({ ... });
      };

      return (
        <div>
          <button onClick={handleSuccess}>成功提示</button>
          <button onClick={handleDelete}>删除确认</button>
          <button onClick={handleNotify}>通知</button>
          {/* ✅ 正确：允许使用 <Modal> 组件标签 */}
          <Modal
            open={modalOpen}
            onCancel={() => setModalOpen(false)}
            title="弹窗标题"
          >
            弹窗内容
          </Modal>
        </div>
      );
    }
    ```

### 1. 页面目录规则

- **页面目录**：所有页面统一放在 `src/pages/Container/`

- **新增页面流程**：

  1. 先创建文件夹

  2. 再创建 `index.jsx`

- **公共组件目录**：所有公共组件统一放在 `src/components/`

- **新增组件流程**：

  1. 先创建文件夹

  2. 再创建 `index.jsx`

### 2. 目录命名规范

- **页面/组件文件夹**：统一使用 **大驼峰（PascalCase）** 命名

  - 示例：`UserList`、`OrderDetail`、`DataList`

- **样式文件**：

  - 若页面/组件需要样式，在同级目录创建 `index.less`
    ```
    index.jsx
    index.less
    ```

  - 若当前页面/组件需要拆分为多个子组件，在同级创建 `components` 文件夹统一存放

    - **组件拆分规范**：当页面或一级组件逻辑较复杂、需要拆分为多个子组件时，应在当前页面目录下创建 `components` 文件夹统一存放。

      `components` 目录中的子组件为**二级组件**，不再单独创建文件夹，组件文件与样式文件直接平铺存放，文件命名统一采用**大驼峰命名法**，例如：`DataList.jsx`、`DataList.less`。

### 3. 路由生成机制

- **自动化路由**：应用的自动化路由由 `@cqsjjb/jjb-dva-runtime` 根据 `src/pages/Container/` 目录中的路由页面文件自动生成路由树

  - 说明：无需手动配置路由，系统会根据页面文件结构自动生成对应的路由映射

### 4. 动态路由规范

- **ID 动态路由**：当页面需要支持动态路由参数（如详情页、编辑页）时，文件夹命名使用 `_id` 后缀

  - 示例：`UserDetail_id`、`OrderEdit_id`

  - 说明：系统会自动将 `_id` 识别为动态路由参数，并在路由中注入对应的 `id` 值

### 5. 应用首页

- **应用首页**：`src/pages/Container/Entry` 为应用的默认首页

  - 约束：非必要情况下禁止修改此目录

### 6. 其他文件夹定义

- 工具库：`src/utils/index.js`

- 枚举值：`src/enumerate/enum/index.js`
  - 用于维护后端返回数据中的枚举值
  - 禁止在代码中硬编码枚举值进行判断比较
  - 必须将枚举值统一维护到此文件中

- 常量：`src/enumerate/constant/index.js`

- React 全局 Context：`src/enumerate/context/index.js`

- Hooks 目录：`src/hooks/`（用于存放自定义 Hooks）

### 7. 枚举值使用规范

- **强制要求**：后端返回数据中包含的枚举值字段（如 `siteRedirectEnum`、`statusEnum` 等），必须统一维护到 `src/enumerate/enum/index.js` 文件中

- **禁止行为**：禁止在代码中直接硬编码枚举值进行判断比较

- **枚举值定义示例**（在 `src/enumerate/enum/index.js` 中）：
  ```javascript
  // 站点跳转类型枚举
  export const SITE_REDIRECT_ENUM = {
    // 站内跳转
    SITE_REDIRECT_IN: 'SITE_REDIRECT_IN',
    // 站外跳转
    SITE_REDIRECT_OUT: 'SITE_REDIRECT_OUT',
  };

  // 用户状态枚举
  export const USER_STATUS_ENUM = {
    // 启用
    ENABLED: 'ENABLED',
    // 禁用
    DISABLED: 'DISABLED',
    // 待审核
    PENDING: 'PENDING',
  };
  ```

- **使用示例**：
  ```javascript
  import { SITE_REDIRECT_ENUM } from '~/enumerate/enum';

  // ✅ 正确：使用枚举值进行比较
  if (record.siteRedirectEnum === SITE_REDIRECT_ENUM.SITE_REDIRECT_IN) {
    // 站内跳转逻辑
  }

  // ❌ 错误：禁止硬编码枚举值
  // if (record.siteRedirectEnum === 'SITE_REDIRECT_IN') {
  //   // 错误做法
  // }
  ```

- **AI 接口创建流程**：
  - **一般情况**：当用户要求新增接口时，AI **必须** 反问用户："请提供接口返回的数据格式（JSON 示例）"
  - **例外情况**：如果提示语中明确要求使用【gen-api-code】工具生成接口文件，则无需询问接口数据格式，直接使用工具生成即可
  - 根据用户提供的数据格式（或工具生成的结果），AI 需要：
    1. 识别数据中的枚举值字段（通常字段名包含 `Enum`、`Type`、`Status` 等关键词）
    2. 在创建接口定义的同时，在 `src/enumerate/enum/index.js` 中创建对应的枚举值定义
    3. 在代码中使用枚举值而非硬编码字符串

### 8. 组件开发规范

- **新增组件推荐使用 Hooks 组件**：

  - **推荐方式**：优先使用函数式组件 + Hooks 的方式开发新组件

  - **优势**：代码更简洁、逻辑更清晰、易于测试和维护

  - **示例**：
    ```javascript
    // ✅ 推荐：使用 Hooks 组件
    import React, { useState, useEffect } from 'react';

    function UserList() {
      const [data, setData] = useState([]);
      
      useEffect(() => {
        // 数据获取逻辑
      }, []);
      
      return <div>用户列表</div>;
    }

    export default UserList;
    ```
