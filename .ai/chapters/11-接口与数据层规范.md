# 十一、接口与数据层规范

> **⚠️ 重要说明**：本章节仅适用于**后端接口**（通过 `declareRequest` 定义）。  
> 如需调用**基座平台API**（如 `base.getClientInfo()`、`base.getTenantInfo()` 等），请参考 [`chapters/19-基座平台API调用规范.md`](../chapters/19-基座平台API调用规范.md)。  
> **基座平台API不使用 `declareRequest`、`Connect` 或 `http`，直接使用全局对象 `base`。**

本系统采用基于 `dva` 的高度抽象数据流管理模式，通过 **"接口定义 - 命名空间映射 - 视图连接"** 三层结构实现业务逻辑与 UI 的彻底解耦。

### 1. 核心架构职责

| 层次           | 对应目录/文件              | 职责描述                                                                             |
| :------------- | :------------------------- | :----------------------------------------------------------------------------------- |
| **API 定义层** | `src/api/`                 | 使用 `declareRequest` 定义具体的后端接口请求，管理 Loading 状态与数据清洗逻辑。      |
| **命名空间层** | `src/enumerate/namespace/` | 定义 **中间层常量 (Namespace)**，作为业务模块的唯一标识，建立视图与 API 的映射关系。 |
| **视图连接层** | `src/pages/Container/`     | 使用 `Connect` 装饰器链接中间层常量，将 API 数据与状态自动注入组件 `props`。         |

### 2. 接口定义规范 (declareRequest)

所有接口必须通过 `@cqsjjb/jjb-dva-runtime/declareRequest` 进行声明。该方法通过字符串 DSL 实现请求配置与数据处理。

必须严格参考对应 MD 文档或 d.ts 文件！

- **基本语法**：

  ```javascript
  declareRequest(
    a?: string,  // 参数1：Loading 状态标识（可选）
    b: string,    // 参数2：请求表达式（必填）
    c?: string   // 参数3：响应数据处理表达式（可选）
  )
  ```

- **参数说明**：

  | 参数 | 类型 | 必填 | 说明 |
  | :--- | :--- | :--- | :--- |
  | a | string | 否 | 请求时绑定的 Loading 状态标识，例如 `"loading"`、`"confirmLoading"` |
  | b | string | 是 | 请求表达式，格式：`Method [> @] URL`，支持完整 http[s] 路径 |
  | c | string | 否 | 响应数据处理表达式，用于从响应结果中取值并赋给目标字段 |

- **定义示例**：

  ```javascript
  // 示例1：获取试卷列表（完整参数）
  export const getExamResDataAction = declareRequest(
    'examResDataLoading', // 参数1：Loading 状态字段名
    'Get > /com-train/exams', // 参数2：请求方法 > 接口路径
    'examResData: [] | res.data || [] & examResDataTotal: 0 | res.totalCount || 0' // 参数3：数据映射与默认值
  );

  // 示例2：仅定义请求（省略参数1和参数3）
  export const getUserInfoAction = declareRequest(
    'Get > /api/user/{id}' // 仅必填参数
  );

  // 示例3：POST 请求使用 @ 标记
  export const createUserAction = declareRequest(
    'createUserLoading',
    'Post > @/api/user', // @ 标记忽略 request 包裹层
    'userId: "" | res.data.id || ""'
  );
  ```

- **命名格式**：`[name]Action` 统一使用 **小驼峰 (camelCase)** 命名

- **请求表达式规范**：

  - **格式**：`Method [> @] URL`

  - **支持的 HTTP 方法**：

    - `Get`：GET 请求
    - `Post`：POST 请求
    - `Put`：PUT 请求
    - `Delete`：DELETE 请求
    - `Patch`：PATCH 请求

  - **@ 标记说明**：

    - **作用**：忽略请求体中 `request` 对象的包裹层，直接传递数据

    - **限制**：**Get 请求不能使用 @**，其他请求方法可选

    - **示例**：

      ```javascript
      // ✅ POST 请求使用 @，忽略 request 包裹
      'Post > @/api/user'

      // ❌ GET 请求禁止使用 @
      'Get > @/api/user/{id}'  // 错误写法
      ```

  - **URL 路径规范**：

    - **普通路径**：例如 `/api/xxx/list`

    - **模板插值**：支持占位符 `{}`，调用时会替换为参数值

      ```javascript
      // 示例：URL 模板插值
      'Get > /api/user/{id}'  // 调用时 {id} 会被替换为实际参数值
      ```

    - **完整 HTTP 路径**：支持完整的 http[s] 路径

    - **请求格式限制**：**仅支持 `application/json` 格式**，其他格式不支持

- **响应表达式规范**：

  - **格式**：`targetField: defaultValue | expression & ...`

  - **组成部分**：

    - `targetField`：目标字段名称

    - `defaultValue`：当结果为空时的默认值

    - `expression`：从响应对象中获取数据的 JS 表达式

    - `&`：支持多个字段连接

    - `res`：固定上下文对象，表示响应结果

  - **示例**：

    ```javascript
    // 示例：多字段映射
    'dataSource: [] | res.data || [] & total: 0 | res.total || 0'
    ```

    表示：

    - 将结果赋值给 `dataSource`，默认值为 `[]`，优先取 `res.data`，如果为空则取 `[]`

    - `&` 连接下一个字段

    - 将结果赋值给 `total`，默认值为 `0`，优先取 `res.total`，如果为空则取 `0`

  - **AI 约束**：**必须根据后端返回结构精确配置此映射**

- **使用规则总结**：

  1. **@ 标记限制**：Get 请求不能用 `@`，其他请求方法可选

  2. **URL 模板插值**：支持路径模板插值 `{id}`，调用时自动替换

  3. **参数可选性**：参数 a（Loading 状态）、c（响应处理）可选，不写也能正常工作

  4. **请求格式**：仅支持 `application/json` 格式

### 3. 命名空间与视图连接

`Connect` 是 `@cqsjjb/jjb-dva-runtime` 提供的高阶组件（HOC），用于将 Dva 模型（Model）与 React 组件连接。它支持自动注入模型 state、工具方法，以及（可选的）请求 Action，简化了组件与数据层的交互。

- **命名空间定义规范**：

  - **集中定义**：命名空间必须集中在 `src/enumerate/namespace/index.js` 中定义

  - **定义方式**：使用 `defineNamespace` 函数定义命名空间常量

  - **命名规则**：命名空间常量对应 `src/api/<namespace>/index.js` 文件

  ```javascript
  // src/enumerate/namespace/index.js
  import { defineNamespace } from '@cqsjjb/jjb-dva-runtime';

  // 这里 user 指的是 src/api/user/index.js
  export const NS_USER = defineNamespace('user');
  
  // 这里 order 指的是 src/api/order/index.js
  export const NS_ORDER = defineNamespace('order');
  
  // 这里 examList 指的是 src/api/examList/index.js
  export const NS_EXAM_LIST = defineNamespace('examList');
  ```

- **请求声明规范**：

  - **文件位置**：每个命名空间常量对应一个 `src/api/<namespace>/index.js` 文件

  - **声明方式**：使用 `declareRequest` 声明接口请求（具体用法参考第2节"接口定义规范"）

  ```javascript
  // src/api/user/index.js
  import { declareRequest } from '@cqsjjb/jjb-dva-runtime';

  // 获取用户信息
  export const fetchUserAction = declareRequest(
    'loading',
    'Get > /api/user/{id}',
    'userInfo: {} | res.data || {}'
  );

  // 新增用户（使用 @ 标记）
  export const addUserAction = declareRequest(
    'confirmLoading',
    'Post > @/api/user'
  );
  ```

- **Connect API 说明**：

  - **函数签名**：`Connect(models, injectActionProps?)`

  - **参数说明**：

    | 参数 | 类型 | 必填 | 说明 |
    | :--- | :--- | :--- | :--- |
    | models | Namespace[] | 是 | 命名空间数组，必须从 `src/enumerate/namespace` 引入 |
    | injectActionProps | boolean | 否 | 是否自动注入 action 方法，默认为 `false` |

  - **injectActionProps 参数说明**：

    - `false`（默认）：只能使用 `dispatchModelAction(namespace, effectAction, payload)` 手动调用

    - `true`：所有 `declareRequest` 定义的请求会自动注入到组件 props 中，可直接调用

- **注入的 Props**：

  1. **State 注入**：

     - `props.user` → 对应 `NS_USER` 模型

     - `props.order` → 对应 `NS_ORDER` 模型

     - 每个命名空间对应一个 props 属性，包含该模型的所有 state（数据字段和 Loading 状态）

  2. **工具方法**（始终存在）：

     - `models`：所有连接的模型

     - `getModelState(namespace, name)`：获取模型状态

     - `resetModelState(namespace, state)`：重置模型状态

     - `dispatchModelAction(namespace, effectAction, payload?)`：手动调用 Action

     - `dispatch(type, payload?)`：Dva dispatch 方法

  3. **Action 方法**（当 `injectActionProps = true` 时才存在）：

     - 例如 `declareRequest` 定义的 `fetchUserAction` 会在组件 props 中直接可用

- **使用方式**：

  - **方式一：默认模式（injectActionProps = false）** - 不推荐

    > **说明**：以下示例仅用于对比理解两种方式的区别，实际开发中请使用推荐的方式二。

    此时不会自动注入 Action，需要手动调用 `dispatchModelAction`：

    ```javascript
    import React, { useEffect } from 'react';
    import { Connect } from '@cqsjjb/jjb-dva-runtime';
    import { NS_USER } from '~/enumerate/namespace';

    function UserProfile({ user, dispatchModelAction }) {
      useEffect(() => {
        dispatchModelAction(NS_USER, 'fetchUserAction', { id: 1 });
      }, []);

      console.log(user?.loading);
      console.log(user?.confirmLoading);
      
      return <div>{user.userInfo?.name}</div>;
    }

    // 注意这里第二个参数没有传（默认为 false）
    export default Connect([NS_USER])(UserProfile);
    ```

  - **方式二：自动注入 Action（injectActionProps = true）** - 推荐

    当 `injectActionProps = true` 时，模型中通过 `declareRequest` 声明的请求会自动注入到组件 props 中，使用时无需 `dispatchModelAction`，可以直接调用：

    ```javascript
    import React, { useEffect } from 'react';
    import { Connect } from '@cqsjjb/jjb-dva-runtime';
    import { NS_USER } from '~/enumerate/namespace';

    function UserProfile({ user, fetchUserAction }) {
      useEffect(() => {
        fetchUserAction({ id: 1 });
      }, []);

      console.log(user?.loading);
      console.log(user?.confirmLoading);
      
      return <div>{user.userInfo?.name}</div>;
    }

    // 第二个参数传 true，启用 Action 自动注入到 props
    export default Connect([NS_USER], true)(UserProfile);
    ```

  - **类组件装饰器语法**：

    如果要连接 class 类组件，使用装饰器语法：

    ```javascript
    import React, { Component } from 'react';
    import { Connect } from '@cqsjjb/jjb-dva-runtime';
    import { NS_USER } from '~/enumerate/namespace';

    @Connect([NS_USER], true)
    class UserProfile extends Component {
      componentDidMount() {
        this.props.fetchUserAction({ id: 1 });
      }

      render() {
        const { user } = this.props;
        return <div>{user.userInfo?.name}</div>;
      }
    }

    export default UserProfile;
    ```

  - **多个模型连接示例**：

    ```javascript
    import React, { useEffect } from 'react';
    import { Connect } from '@cqsjjb/jjb-dva-runtime';
    import { NS_USER, NS_ORDER } from '~/enumerate/namespace';

    function Dashboard({ user, order, fetchUserAction, fetchOrdersAction }) {
      useEffect(() => {
        fetchUserAction({ id: 1 });
        fetchOrdersAction();
      }, []);

      return (
        <div>
          <h3>{user?.userInfo?.name}</h3>
          <ul>
            {order.list?.map(o => (
              <li key={o.id}>{o.title}</li>
            ))}
          </ul>
        </div>
      );
    }

    export default Connect([NS_USER, NS_ORDER], true)(Dashboard);
    ```

  - **重置状态示例**：

    ```javascript
    import { useEffect } from 'react';
    import { Connect } from '@cqsjjb/jjb-dva-runtime';
    import { NS_USER } from '~/enumerate/namespace';

    function UserProfile({ user, fetchUserAction, resetModelState }) {
      useEffect(() => {
        fetchUserAction({ id: 1 });
        
        return () => {
          // 组件销毁时重置状态
          resetModelState(NS_USER, {
            loading: false,
            userInfo: {}
          });
        };
      }, []);

      return <div>{user.userInfo?.name}</div>;
    }

    export default Connect([NS_USER], true)(UserProfile);
    ```

- **使用规范总结**：

  1. 命名空间必须集中在 `src/enumerate/namespace/index.js` 中定义，使用 `defineNamespace` 函数

  2. 请求声明必须放在 `src/api/<namespace>/index.js` 中，使用 `declareRequest`

  3. `Connect` 负责把 state、action 方法注入到组件

  4. 如果 `injectActionProps = true`，state、action 自动注入到组件 props，免去手动处理

  5. **禁止行为**：禁止在页面内使用 `useState` 管理本应由 `declareRequest` 处理的接口数据或 Loading 状态

### 4. 目录命名规范

- **API 文件夹**：统一使用 **小驼峰 (camelCase)** 命名，例如"用户列表" `src/api/userList/`。

### 5. 字典数据获取规范

- **统一使用 Hooks 方式获取字典数据**：

  - **实现流程**：
    1. 在 `src/api/<namespace>/index.js` 中定义字典数据接口（使用传统 `http.Get()`、`http.Post()` 等方式，**不使用 `declareRequest`**）
    2. 在 `src/hooks/` 中创建对应的数据 Hook
    3. 在页面/组件中使用 Hook 获取字典数据

  - **接口定义示例**（在 `src/api/dict/index.js` 中）：
    ```javascript
    import { http } from '@cqsjjb/jjb-common-lib';

    // 获取用户状态字典
    export const getUserStatusDict = () => {
      return http.Get('/api/dict/user-status');
    };

    // 获取部门列表字典
    export const getDepartmentDict = () => {
      return http.Get('/api/dict/department');
    };
    ```

  - **Hook 定义示例**（在 `src/hooks/useDict.js` 中）：
    ```javascript
    import { useState, useEffect } from 'react';
    import { getUserStatusDict, getDepartmentDict } from '~/api/dict';

    // 用户状态字典 Hook
    export const useUserStatusDict = () => {
      const [options, setOptions] = useState([]);
      const [loading, setLoading] = useState(false);

      useEffect(() => {
        const fetchDict = async () => {
          setLoading(true);
          try {
            const res = await getUserStatusDict();
            setOptions(res.data || []);
          } catch (error) {
            console.error('获取用户状态字典失败:', error);
          } finally {
            setLoading(false);
          }
        };
        fetchDict();
      }, []);

      return { options, loading };
    };

    // 部门列表字典 Hook
    export const useDepartmentDict = () => {
      const [options, setOptions] = useState([]);
      const [loading, setLoading] = useState(false);

      useEffect(() => {
        const fetchDict = async () => {
          setLoading(true);
          try {
            const res = await getDepartmentDict();
            setOptions(res.data || []);
          } catch (error) {
            console.error('获取部门字典失败:', error);
          } finally {
            setLoading(false);
          }
        };
        fetchDict();
      }, []);

      return { options, loading };
    };
    ```

  - **使用示例**（在页面/组件中）：
    ```javascript
    import React from 'react';
    import { Select } from 'antd';
    import { useUserStatusDict, useDepartmentDict } from '~/hooks/useDict';

    function UserForm() {
      // 使用 Hook 获取字典数据
      const { options: statusOptions, loading: statusLoading } = useUserStatusDict();
      const { options: deptOptions, loading: deptLoading } = useDepartmentDict();

      return (
        <Form>
          <Form.Item name="status" label="用户状态">
            <Select
              showSearch
              placeholder="请选择用户状态"
              allowClear
              loading={statusLoading}
              options={statusOptions}
            />
          </Form.Item>
          <Form.Item name="department" label="所属部门">
            <Select
              showSearch
              placeholder="请选择部门"
              allowClear
              loading={deptLoading}
              options={deptOptions}
            />
          </Form.Item>
        </Form>
      );
    }
    ```

  - **注意事项**：
    - 字典数据接口**不使用 `declareRequest`**，使用传统的 `http.Get()`、`http.Post()` 等方式
    - Hook 中需要处理 loading 状态和错误处理
    - 字典数据可以缓存，避免重复请求（可在 Hook 中实现缓存逻辑）
